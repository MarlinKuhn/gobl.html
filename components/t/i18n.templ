package t

import (
	"github.com/invopop/ctxi18n/i18n"
	"github.com/invopop/gobl/cal"
	"github.com/invopop/gobl/num"
	"github.com/invopop/gobl/currency"
)

// T wraps around the i18n T method
templ T(key string, args ...any) {
	{ i18n.T(ctx, key, args...) }
}

// N wraps around the i18n N method
templ N(key string, n int, args ...any) {
	{ i18n.N(ctx, key, n, args...) }
}

// L localizes a GOBL num.Amount, num.Percentage, cal.DateTime, or cal.Date according
// to the rules defined in the context.
templ L(a any) {
	{ localize(ctx, a) }
}

// LM localizes amounts using the currency and formatter defined in the context.
templ LM(a num.Amount) {
	{ localizeMoney(ctx, a) }
}

// LC localizes and amount using the formatting defined by the specified currency,
// ignoring any formatter defined in the context.
templ LC(a num.Amount, cur currency.Code) {
	{ localizeCurrency(ctx, a, cur) }
}

// Scope helps set a scope around the context
templ Scope(key string) {
	if ctx = i18n.WithScope(ctx, key); true {
		{ children... }
	}
}

func localize(ctx context.Context, a any) string {
	switch v := a.(type) {
	case num.Amount:
		nf := numFormatter(ctx).WithoutUnit()
		return nf.Amount(v)
	case num.Percentage:
		nf := numFormatter(ctx).WithoutUnit()
		return nf.Percentage(v)
	case cal.DateTime:
		cf := calFormatter(ctx)
		return v.In(cf.Location).Format(cf.DateTime)
	case cal.Date:
		cf := calFormatter(ctx)
		return v.Time().Format(cf.Date)
	default:
		return "!(UNKOWN TYPE)"
	}
}

func localizeMoney(ctx context.Context, a num.Amount) string {
	f := numFormatter(ctx)
	return f.Amount(a)
}

func localizeCurrency(_ context.Context, a num.Amount, cur currency.Code) string {
	f := cur.Def().Formatter()
	return f.Amount(a)
}
